con = "1011011111100001010100010110001010001010111000100100001111110110101010001000100001011010"

def TriadUpd(a, b, c, msg):

    t1 = a[68] ^ a[80] ^ (b[85] & c[85])
    t2 = b[64] ^ b[88]
    t3 = c[68] ^ c[88]
    
    z = t1 ^ t2 ^ t3

    t1 = t1 ^ (a[73] & a[79]) ^ b[66] ^ msg
    t2 = t2 ^ (b[65] & b[87]) ^ c[84] ^ msg
    t3 = t3 ^ (c[77] & c[87]) ^ a[74] ^ msg
    
    a = [0, t3] + a[1:80]
    b = [0, t1] + b[1:88]
    c = [0, t2] + c[1:88]

    return (a, b, c, z)
    
def TriadP(a, b, c):
    
    for _ in range(1, 1024+1):
        (a, b, c, z) = TriadUpd(a, b, c, 0)
        
    return (a, b, c)

def TriadHash(K, N, M):
    if len(K) != 128 or len(N) != 96:
        raise ValueError("[ERROR] Key size must be 128 bits and nonce size must be 96 bits!")
            
    a = [0]*(80+1)
    b = [0] + [int(i) for i in con]
    c = [0]*(88+1)
    
    M.append(1)
    rem = len(M)%32
    if rem != 0:
        M.extend([0]*(32-rem))
        
    MB = []
    for i in range(0, int(len(M)/32)):
        temp = M[32*i+24:32*i+32] + M[32*i+16:32*i+24] + M[32*i+8:32*i+16] + M[32*i:32*i+8]
        MB.append(temp)
    
    hlen = len(MB) 

    for i in range(hlen):
        for j in range(1, 33):
            a[j] = a[j] ^ MB[i][j-1]
        (a, b, c) = TriadP(a, b, c)

    Z = a[1:81] + b[1:49]
    (a, b, c) = TriadP(a, b, c)
    Z = a[1:81] + b[1:49] + Z
    
    ZZ = []
    for i in range(int(len(Z)/8)):
        ZZ.append(Z[8*i:8*i+8])
    
    ZZ.reverse()
        
    Z = []
    for i in ZZ:
        Z.extend(i)
        
    return Z
      
if __name__ == "__main__":
    '''
    [Sample inputs & outputs]
    INPUT #1
    00000000000000010000001000000011000001000000010100000110000001110000100000001001000010100000101100001100000011010000111000001111
    000000000000000100000010000000110000010000000101000001100000011100001000000010010000101000001011
    0011010000000011100010010011000100110000001001101111011000000110101110011011011000110100010001001001111111111101110010100101000110010110000000110000111100101010101001110111100100100001001110000110000101110100001000000100011001101110011010100100101110111001001100100000000010011110011010110000011011001011001110000101100111011111111011111001100101010111110101100001011100111110101110111100111111101010100000011001101110010100101110101011010101011010001110011110111111101111100111111111101110101100111111000001011110100101011011001110111110011111110110001110111111011100100101001011001111110111000110100011001001101010100001000111100011100001111100001011100011011010011010100110010000000010100110010110001000100000111111011010110011010100001010110011000001100101100001111011011000100011001010110000110000000010011010110000011111111010001010001000101011001001011000111110100001010000101011010010101000101101010100001000110110100110100111100101110000010011011000001001010100011011001000011110001100110101

    OUTPUT #1
    1100110110001111000011100101111101010100011010110010100001100100000100100010010011001101110000011011101100000000000011000100111110110110101000100000111001010000100011011001000101100100111100011110100110000000101010101110000000111111101101101011010101000101

    INPUT #2
    00000000000000010000001000000011000001000000010100000110000001110000100000001001000010100000101100001100000011010000111000001111
    000000000000000100000010000000110000010000000101000001100000011100001000000010010000101000001011


    OUTPUT #2
    1011101110011000000110100001010011101111101010001110101001011101001100001000111001111001010101011111011101000000001011001001010000011011001000001001111010100100000100110001100111111110111011100011110101010111000110100100110001000100000101110101111001101110

    INPUT #3
    00000000000000010000001000000011000001000000010100000110000001110000100000001001000010100000101100001100000011010000111000001111
    000000000000000100000010000000110000010000000101000001100000011100001000000010010000101000001011
    00000000000000010000001000000011000001000000010100000110000001110000100000001001000010100000101100001100000011010000111000001111

    OUTPUT #3
    0011010101010100000001100011010000011110101111111011011100001000011010001100001001011010000100001010011100011000001111111011011101101011111100101101011111000000001000011000011000010111111111010000101101000001111000010001111000010110100001111110101000110100
    '''

    key = [int(i) for i in list(input("\nKey (16 bytes or 128 bits binary string): "))]
    nonce = [int(i) for i in list(input("\nNonce (12 bytes or 96 bits binary string): "))]

    message = [int(i) for i in list(input("\nMessage (binary string with size multiple of 8): "))]
    if(len(message)%8 != 0):
        raise ValueError("[ERROR] Message size must be mulitple of 8!")

    myHash = TriadHash(key, nonce, message)
    myHash = ''.join(str(b) for b in myHash)
    print(f"\nHash: {myHash}\n")
